#
# For docs: https://github.com/interactiveaudiolab/ppgs/tree/master
#
from pathlib import Path
import os, sys

# Fixes torchcodec and ffmpeg issues
ffmpeg_dll_dir = Path(r"C:/Users/jackm/miniconda3/Library/bin")  # adjust if your conda root differs
assert ffmpeg_dll_dir.exists(), ffmpeg_dll_dir
os.add_dll_directory(str(ffmpeg_dll_dir))

import os
import torch
import torchcodec
import ppgs
import argparse
import matplotlib.pyplot as plt
import numpy as np

def plot_ppg(ppgs_tensor, wav_filename, out_dir):
    """[ppg_tensor] is a tensor on the CPU, generated by ppgs.from_audio()"""
    
    # Suppose your PPG tensor is called ppgs
    # ppgs.shape = (1, num_phonemes, frames)
    ppg = ppgs_tensor[0].numpy()  # remove batch dimension, shape=(num_phonemes, frames)

    plt.figure(figsize=(18, 18))
    plt.imshow(ppg, aspect='auto', origin='lower', cmap='viridis')
    plt.colorbar(label='Posterior Probability')
    plt.xlabel('Time Frame')
    plt.ylabel('Phoneme Index')
    plt.yticks(np.arange(len(ppgs.PHONEMES)), ppgs.PHONEMES)
    plt.title('Phonetic Posteriorgram (PPG)')
    plt.savefig(f"{out_dir}/ppg_plot_{wav_filename}.png")
    
def load_wav_to_tensor(wav_dir):
    """Load WAV files in the given directory into a tensor of shape
    (num_files, 1, audio_frames). Return source paths for filename matching when saving.
    """
    wav_audio = []
    wav_paths = []

    for root, dirs, files in os.walk(wav_dir):
        for file in files:
            if file.lower().endswith(".wav"):
                wav_path = os.path.join(root, file)
                wav_paths.append(wav_path)

                # Load speech audio at correct sample rate (1D array expected).
                audio = ppgs.load.audio(wav_path)
                # print(wav_path, f"shape: {audio.shape}")
                wav_audio.append(np.asarray(audio))

    if not wav_audio:
        raise ValueError("No WAV files found in directory.")

    # Pad to max length
    max_len = max(a.shape[1] for a in wav_audio)
    padded = [np.pad(a, (0, max_len - a.shape[1])) if a.shape[1] < max_len else a
              for a in wav_audio]

    # Convert list → single NumPy array → tensor
    padded_np = np.array(padded, dtype=np.float32)  # (num_files, audio_frames)
    wav_tensor = torch.from_numpy(padded_np).unsqueeze(1)  # → (num_files, 1, audio_frames)

    return wav_tensor, wav_paths

def save_ppgs_per_file(ppg_tensor, wav_paths, out_dir, savePlots=False):
    """
    ppg_tensor: (num_files, num_phonemes, frames)
    wav_paths: list of original WAV filepaths in same order
    """
    

    for i, wav_path in enumerate(wav_paths):
        base = os.path.splitext(os.path.basename(wav_path))[0]
        out_path = os.path.join(out_dir, base + ".ppg.pt")

        torch.save(ppg_tensor[i], out_path)
        
        # Save image 
        plot_ppg(ppg_tensor[i], base, out_dir)
        

def generate_ppgs(wav_dir, output_dir):
    audio_tensor, wav_paths = load_wav_to_tensor(wav_dir)
    
    # Choose a gpu index to use for inference. Set to None to use cpu.
    gpu = 0

    # Infer PPGs. shape (batch, len(ppgs.PHONEMES), frames)
    ppgs_tensor = ppgs.from_audio(audio_tensor, ppgs.SAMPLE_RATE, gpu=gpu)
    
    # Save to .pt files
    save_ppgs_per_file(ppgs_tensor.cpu(), wav_paths, output_dir)
    
    
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--wav_dir_root",
        default="../data/train/Normalised_audio-chunks",
        help="Directory from which to read WAV files as input. Must have subfolders 'cc' and 'cd'.",
    )
    parser.add_argument(
        "--output_dir",
        default="ppgs",
        help="Directory to save PPG plots.",
    )
    args = parser.parse_args()
    
    os.makedirs( args.output_dir, exist_ok=True)
    
    # CUDA check
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"Using device: {device}")

    # PPGS for AD postive
    generate_ppgs(
        os.path.join(args.wav_dir_root, "cd"), 
         os.path.join(args.output_dir, "cd")
        )

    # PPGS for AD negative (control)
    generate_ppgs(
        os.path.join(args.wav_dir_root, "cc"), 
         os.path.join(args.output_dir, "cc")
        )


if __name__=="__main__":
    main()