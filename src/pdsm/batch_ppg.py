#
# For docs: https://github.com/interactiveaudiolab/ppgs/tree/master
#
from pathlib import Path
import os, sys

# Fixes torchcodec and ffmpeg issues
ffmpeg_dll_dir = Path(r"C:/Users/jackm/miniconda3/Library/bin")  # adjust if your conda root differs
assert ffmpeg_dll_dir.exists(), ffmpeg_dll_dir
os.add_dll_directory(str(ffmpeg_dll_dir))

import os
import torch
import torchcodec
import ppgs
import argparse
import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm

def plot_ppg(ppgs_tensor, wav_filename, out_dir):
    """[ppg_tensor] is a tensor on the CPU, generated by ppgs.from_audio()"""
    
    # Suppose your PPG tensor is called ppgs
    # ppgs.shape = (num_phonemes, frames)
    ppg = ppgs_tensor.float().numpy()  # remove batch dimension, shape=(num_phonemes, frames)

    plt.figure(figsize=(18, 18))
    plt.imshow(ppg, aspect='auto', origin='lower', cmap='viridis')
    plt.colorbar(label='Posterior Probability')
    plt.xlabel('Time Frame')
    plt.ylabel('Phoneme Index')
    plt.yticks(np.arange(len(ppgs.PHONEMES)), ppgs.PHONEMES)
    plt.title('Phonetic Posteriorgram (PPG)')
    plt.savefig(f"{out_dir}/ppg_plot_{wav_filename}.png")
    
def load_wav_to_tensor(wav_dir):
    """Load WAV files in the given directory into a tensor of shape
    (num_files, 1, audio_frames). Return source paths for filename matching when saving.
    """
    print("loading wavs")
    wav_audio = []
    wav_paths = []

    for root, dirs, files in os.walk(wav_dir):
        for file in files:
            if file.lower().endswith(".wav"):
                wav_path = os.path.join(root, file)
                wav_paths.append(wav_path)

                # Load speech audio at correct sample rate (1D array expected).
                audio = ppgs.load.audio(wav_path)
                # print(wav_path, f"shape: {audio.shape}")
                wav_audio.append(np.asarray(audio))

    if not wav_audio:
        raise ValueError("No WAV files found in directory.")

    # Pad to max length
    max_len = max(a.shape[1] for a in wav_audio)

    padded = [
        np.pad(a, ((0, 0), (0, max_len - a.shape[1]))) if a.shape[1] < max_len else a
        for a in wav_audio
    ]

    # Convert list → single NumPy array → tensor
    padded_np = np.stack(padded, axis=0)  # shape: [N, 1, max_len]
    wav_tensor = torch.from_numpy(padded_np)  # → (num_files, 1, audio_frames)

    return wav_tensor, wav_paths

def save_ppgs_per_file(ppg_tensor, wav_paths, out_dir, savePlots=False):
    """
    ppg_tensor: (num_files, num_phonemes, frames)
    wav_paths: list of original WAV filepaths in same order
    """
    
    os.makedirs(out_dir, exist_ok=True)
    
    print("saving ppgs .pt files")
    for i, wav_path in enumerate(wav_paths):
        base = os.path.splitext(os.path.basename(wav_path))[0]
        out_path = os.path.join(out_dir, base + "_ppg.pt")

        torch.save(ppg_tensor[i], out_path)
        
        # Save image 
    
    if savePlots:
        print("saving ppg plots")
        for i, wav_path in enumerate(wav_paths):
            base = os.path.splitext(os.path.basename(wav_path))[0]

            plot_ppg(ppg_tensor[i], base, out_dir)
        
    
def generate_ppgs(wav_dir,  output_dir, gpu_idx=None, savePlot=False):
    """https://github.com/interactiveaudiolab/ppgs/tree/master"""
    
    os.makedirs(output_dir, exist_ok=True)
    
    for root, dirs, files in os.walk(wav_dir):
        for file in tqdm(files, desc="Processing WAVs"):
            if file.lower().endswith(".wav"):
                wav_path = os.path.join(root, file)
                
                ppg = infer_ppg_from_wav(wav_path)
                
                save_ppg(ppg, wav_path, output_dir)
                

                
                

def infer_ppg_from_wav(wav_path, gpu_idx=None, savePlot=False):
    base = os.path.splitext(os.path.basename(wav_path))[0]
    tqdm.write(f"Processing {base}")
    # load audio using torchcodec
    audio = ppgs.load.audio(wav_path)
    
    # infer ppg from non padded audio
    pp = ppgs.from_audio(audio, ppgs.SAMPLE_RATE, gpu=gpu_idx)


def save_ppg(ppg, wav_path,out_dir, savePlot=False):
    
    base = os.path.splitext(os.path.basename(wav_path))[0]
    out_path = os.path.join(out_dir, "PPG_" + base + ".pt")
    
    base_out = os.path.splitext(os.path.basename(out_path))[0]
    tqdm.write(f"Saving {base_out}")
    # save to tensor file
    torch.save(ppg, out_path)
    
    # save graphic using matplotlib
    if savePlot:
        plot_ppg(ppg, base, out_dir)
    
    
    
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--wav_dir_root",
        default="../data/train/Normalised_audio-chunks",
        help="Directory from which to read WAV files as input. Must have subfolders 'cc' and 'cd'.",
    )
    parser.add_argument(
        "--output_dir",
        default="ppgs",
        help="Directory to save PPG plots.",
    )
    args = parser.parse_args()
    
    os.makedirs( args.output_dir, exist_ok=True)
    
    # CUDA check
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"Using device: {device}")
    

    output_dir_cd = os.path.join(args.output_dir, "cd")
    # PPGS for AD postive
    generate_ppgs(
        os.path.join(args.wav_dir_root, "cd"),
        output_dir_cd
        )
    
    
    output_dir_cc = os.path.join(args.output_dir, "cc")
    # PPGS for AD negative (control)
    generate_ppgs(
        os.path.join(args.wav_dir_root, "cc"),
        output_dir_cc
        )
    


if __name__=="__main__":
    main()